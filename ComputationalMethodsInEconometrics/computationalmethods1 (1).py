# -*- coding: utf-8 -*-
"""ComputationalMethods1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Vb8OJF46MjS80Mmvgs5dJWu9SKScl6on
"""

import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
import statsmodels.api as sm
import seaborn as sns
from numpy.linalg import multi_dot
from scipy.stats import expon

df = pd.read_csv("/content/Regressors.txt", header = None)
df.head

m = np.array(df)
m_trans = m.transpose()
first_mult = multi_dot([m_trans, m])
inverse = np.linalg.inv(first_mult) 
sec_mult = multi_dot([m, inverse, m_trans])
sec_mult.shape
identity_matrix = np.identity(100)
identity_matrix
sub =np.subtract(identity_matrix, sec_mult)

df_y = pd.read_csv("/content/Observables.txt", header = None)
df_y.head
y_array = np.array(df_y)
epsilon = multi_dot([sub, y_array])
epsilon[0:5]

eps_diff = np.diff(epsilon, n=1, axis=0,)
eps_sqr = np.square(eps_diff)
sum1 = np.sum(eps_sqr, axis=0)
sum1

eps_den = np.square(epsilon)
sum2 = np.sum(eps_den)
sum2

test_statistic = list(sum1/sum2)
test_statistic

list_tstats = [test_statistic[0]]
for n in range(9999):
  #ran_exp = np.random.exponential(1,1000)
  ran_exp = np.random.standard_normal(size = 1000)
  eps_diff = np.diff(ran_exp, n=1, axis=0,)
  eps_sqr1 = np.square(eps_diff)
  ep_sqr = np.square(ran_exp)
  suma = np.sum(eps_sqr1)
  sumb = np.sum(ep_sqr)
  t_stat = suma/sumb
  list_tstats.append(t_stat)
  n = n +1

list_tstats.sort()
list_tstats[0:5]

k1 = int((9999+1)*0.1/2 + 1)
k2 = int((1-0.1/2)*(9999+1))

rej_c1 = list_tstats[k1-1]

rej_c2 = list_tstats[k2-1]
rej_c2

def check(list, val):
  num = 0
  for n in list:
    if n <= val:
      num = num+1
    else:
      num = num
  return num

value = check(list_tstats, test_statistic[0])
value

def check2(list, val):
  num = 0
  for n in list:
    if n >= val:
      num = num+1
    else:
      num = num
  return num

value2 = check2(list_tstats, test_statistic[0])
value2

p_value = 2 *min((value/10000, value2/9999))
p_value

